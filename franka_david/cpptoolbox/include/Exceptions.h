#ifndef MY_EXCEPTIONS_H
#define MY_EXCEPTIONS_H

#include <iostream>
#include <string>
#include <cstring>
#include <cstdio>
#include <stack>

class Exception {
public:
    //! Constructors
	Exception() : errmsg("Unknown exception") { print(); exit(EXIT_FAILURE); }
    Exception( const std::string & e ) : errmsg(e) {	print();exit( EXIT_FAILURE );           }
    Exception( const Exception & e )				{	errmsg = e.errmsg;                      }
    Exception & operator =( const Exception & e )	{	errmsg = e.errmsg;	return *this;		}
    void print(){
		std::cout << "\n" << errmsg << "\n\nPress Enter to exit...";
		getchar();
	}
    //! Destructor
    virtual ~Exception() { }
private:
    std::string errmsg;
};

/**
*  Base class for errors generated by ORO_Geometry
*/
class Error {
public:
	/** Returns a description string describing the error.
	*  the returned pointer only guaranteed to exists as long as
	* the Error object exists.
	*/
	virtual ~Error() {}
	virtual const char* Description() const { return "Unspecified Error\n"; }

	virtual int GetType() const { return 0; }
};
class Error_IO : public Error {
	std::string msg;
	int _typenr;
public:
	Error_IO(const std::string& _msg = "Unspecified I/O Error", int typenr = 0) :msg(_msg), _typenr(typenr) {}
	virtual const char* Description() const { return msg.c_str(); }
	virtual int GetType() const { return _typenr; }
};
class Error_BasicIO : public Error_IO {};
class Error_BasicIO_File : public Error_BasicIO {
public:
	virtual const char* Description() const { return "Error while reading stream"; }
	virtual int GetType() const { return 1; }
};
class Error_BasicIO_Exp_Delim : public Error_BasicIO {
public:
	virtual const char* Description() const { return "Expected Delimiter not encountered"; }
	virtual int GetType() const { return 2; }
};
class Error_BasicIO_Not_A_Space : public Error_BasicIO {
public:
	virtual const char* Description() const { return "Expected space,tab or newline not encountered"; }
	virtual int GetType() const { return 3; }
};
class Error_BasicIO_Unexpected : public Error_BasicIO {
public:
	virtual const char* Description() const { return "Unexpected character"; }
	virtual int GetType() const { return 4; }
};
class Error_BasicIO_ToBig : public Error_BasicIO {
public:
	virtual const char* Description() const { return "Word that is read out of stream is bigger than maxsize"; }
	virtual int GetType() const { return 5; }
};
class Error_BasicIO_Not_Opened : public Error_BasicIO {
public:
	virtual const char* Description() const { return "File cannot be opened"; }
	virtual int GetType() const { return 6; }
};
class Error_FrameIO : public Error_IO {};
class Error_Frame_Vector_Unexpected_id : public Error_FrameIO {
public:
	virtual const char* Description() const { return "Unexpected identifier, expecting a vector (explicit or ZERO)"; }
	virtual int GetType() const { return 101; }
};
class Error_Frame_Frame_Unexpected_id : public Error_FrameIO {
public:
	virtual const char* Description() const { return "Unexpected identifier, expecting a Frame (explicit or DH)"; }
	virtual int GetType() const { return 102; }
};
class Error_Frame_Rotation_Unexpected_id : public Error_FrameIO {
public:
	virtual const char* Description() const { return "Unexpected identifier, expecting a Rotation (explicit or EULERZYX, EULERZYZ, RPY,ROT,IDENTITY)"; }
	virtual int GetType() const { return 103; }
};
class Error_MotionIO : public Error {};
class Error_MotionIO_Unexpected_Traj : public Error_MotionIO {
public:
	virtual const char* Description() const { return "Trajectory type keyword not known"; }
	virtual int GetType() const { return 2002; }
};
class Error_MotionPlanning : public Error {};
class Error_MotionPlanning_Circle_ToSmall : public Error_MotionPlanning {
public:
	virtual const char* Description() const { return "Circle : radius is to small"; }
	virtual int GetType() const { return 3001; }
};
class Error_MotionPlanning_Circle_No_Plane : public Error_MotionPlanning {
public:
	virtual const char* Description() const { return "Circle : Plane for motion is not properly defined"; }
	virtual int GetType() const { return 3002; }
};
class Error_MotionPlanning_Not_Applicable : public Error_MotionPlanning {
public:
	virtual const char* Description() const { return "Method is not applicable for this derived object"; }
	virtual int GetType() const { return 3004; }
};
class Error_MotionPlanning_Not_Feasible : public Error_MotionPlanning {
	int reason;
public:
	Error_MotionPlanning_Not_Feasible(int _reason) :reason(_reason) {}
	virtual const char* Description() const {
		return "Motion Profile with requested parameters is not feasible";
	}
	virtual int GetType() const { return 3100 + reason; }
};
class Error_Not_Implemented : public Error {
public:
	virtual const char* Description() const { return "The requested object/method/function is not implemented"; }
	virtual int GetType() const { return 7000; }
};

#endif // MY_EXCEPTIONS_H

#ifndef ERROR_STACK_H
#define ERROR_STACK_H
/*
* \todo
*    IOTrace-routines store in static memory, should be in thread-local memory.
* pushes a description of the current routine on the IO-stack trace
*/
void IOTrace(const std::string& description);
//! pops a description of the IO-stack
void IOTracePop();
//! outputs the IO-stack to a stream to provide a better error message.
void IOTraceOutput(std::ostream& os);
//! outputs one element of the IO-stack to the buffer (maximally size chars)
//! returns empty string if no elements on the stack.
void IOTracePopStr(char* buffer, int size);


#endif
